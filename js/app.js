/**
 * @version v1.0.0
 * @author Janis Rublevskis <janis@xit.lv>
 * @todo check if fontforge installed on windows
 * @todo check if fontforge installed on osx
 *
 * @todo tune up html template
 *
 * @todo pack app for linux
 * @todo pack app for windows
 * @todo pack app for macOs
 * @todo add icon
 */
"use strict";

const path = require("path"),
    fs = require("fs"),
    execSync = require("child_process").execSync,
    exec = require("child_process").exec,
    bn = require("bootstrap.native"),
    os = require("os"),
    ttf2eot = require(path.resolve(process.cwd(), path.join('js', 'ttf2eot.js')));

document.title += ' ' + process.env.npm_package_version;

const win = nw.Window.get();
const App = nw.App;

const helper = {
    extend: function () {
        for (let i = 1; i < arguments.length; i++)
            for (let key in arguments[i])
                if (arguments[i].hasOwnProperty(key))
                    arguments[0][key] = arguments[i][key];
        return arguments[0];
    },
    addEvent: function (el, type, handler) {
        if (el.attachEvent) el.attachEvent('on' + type, handler); else el.addEventListener(type, handler);
    },

    live: function (event, selector, callback, context) {
        if (selector.match(/^#/)) {
            selector = selector.replace(/^#/, '');
            this.addEvent(context || document, event, function (e) {
                let found, el = e.target || e.srcElement;
                while (el && !(found = el.id === selector)) el = el.parentElement;
                if (found) callback.call(el, e);
            });
        } else {
            this.addEvent(context || document, event, function (e) {
                let qs = (context || document).querySelectorAll(selector);
                if (qs) {
                    let el = e.target || e.srcElement, index;
                    while (el && ((index = Array.prototype.indexOf.call(qs, el)) === -1)) {
                        el = el.parentElement;
                    }
                    if (index > -1) callback.call(el, e);
                }
            });
        }

    },
    show: function (el) {
        el.style.display = 'block';
    },

    hide: function (el) {
        el.style.display = 'none';
    },

    append: function (el, data) {
        el.appendChild(this.html2element(data));
    },

    prepend: function (el, data) {
        el.insertBefore(this.html2element(data), el.firstChild);
    },

    html2element: function (html) {
        let template = document.createElement('template');
        template.innerHTML = html;
        return template.content.firstChild;
    },
    debugLines: 1,
    debug: function (data) {
        let dw = this.createDebugWin();
        console.log(data);
        if (typeof data === 'object') {
            data = JSON.stringify(data);
        }
        dw.value = "\n" + this.debugLines++ + '. ' + data.toString() + dw.value;
    },
    createDebugWin: function () {
        let dw = document.getElementById('debug-window');
        if (dw === null) {
            let newDw = '<div class="form-group">' +
                '    <label for="exampleFormControlTextarea1">Debug window</label>' +
                '    <textarea id="debug-window" class="form-control" id="exampleFormControlTextarea1" rows="3"></textarea>' +
                '  </div>';
            this.append(document.querySelector('.container'), newDw);
            dw = document.getElementById('debug-window');
        }
        return dw;
    }
};

const app = {
    bigLoader: document.getElementById('big-loader'),
    init: function () {
        /**
         * All _blank links to external browser
         */
        let scope = this;
        helper.live('click', 'a[target=_blank]', function (event) {
            event.preventDefault();
            nw.Shell.openExternal(this.href);
            if (scope.isDebug()) {
                helper.debug('External click: ' + this.href);
            }
        });


        this.initSettings();
        this.debugger();
        this.emptyTemp();
        this.buildMenu();
        this.fileChooser();
        this.removeItem();
        this.clearList();
        this.generateFonts();
        this.pack();
        this.clickEvents();
        helper.hide(this.bigLoader);
    },

    /** =========================== settings ===================================== **/
    /**
     * default settings
     */
    defaultSettings: {
        debug: 1,
        settingsFile: 'font-convert-settings.json',

        /**
         * path to fontforge executable
         */
        fontForgePath: null
    },

    /**
     * settings generated by initSettings
     */
    settings: {},

    settingsWindow: function (options) {
        options = options || {
            focus: ''
        };
        if (this.isDebug()) {
            helper.debug("Settings window opened");
        }
        if (options.focus) {
            document.getElementById('settings-window').addEventListener("shown.bs.modal", function () {
                try {
                    document.getElementById(options.focus).focus();
                } catch (e) {
                }
            }, false);
        }
        this.settingsModal.show();
    },

    /**
     * Add setting to property
     *
     * @param key
     * @param value
     */
    settingsSet: function (key, value) {
        this.settings[key] = value;
    },

    settingsGet: function (key) {
        return this.settings[key] || null;
    },

    /**
     * reload settings
     * @param newSettings object
     */
    reloadSettings: function (newSettings) {
        if (newSettings) {
            this.settings = helper.extend(this.settings, newSettings)
        }

        let debugWindow = document.getElementById("debug-window");
        if (!this.settingsGet("debug")) {
            if (debugWindow) {
                debugWindow = debugWindow.parentNode;
                debugWindow.parentNode.removeChild(debugWindow);
            }
        } else {
            if (!debugWindow) {
                helper.createDebugWin();
            }
        }
    },

    /**
     * save settings to file
     *
     * @param settings object
     */
    saveSettings: function (settings) {
        let filePath = path.join(App.dataPath, this.settings.settingsFile);
        let success = false;
        try {
            fs.writeFileSync(filePath, JSON.stringify(settings), "utf8");
            success = true;
            if (this.isDebug()) {
                helper.debug("Settings saved to: " + filePath);
            }
        } catch (e) {
            if (this.isDebug()) {
                helper.debug("There was an error attempting to save your data.");
            }
        }

        return success;
    },

    putSettingsToView: function (settings) {
        this.putSettingToView("fontForgePath", settings.fontForgePath || "");
        this.putSettingToView("debug", settings.debug || "");
    },

    putSettingToView: function (id, val) {
        switch (id) {
            case "debug": //checkbox
                document.getElementById(id).checked = parseInt(val, 10) === 1;
                break;
            default:
                document.getElementById(id).value = val;
                break;
        }
    },

    /**
     * init settings
     */
    initSettings: function () {
        let scope = this;
        this.reloadSettings(this.defaultSettings);
        let settings = {};
        try {
            settings = JSON.parse(fs.readFileSync(path.join(App.dataPath, this.settings.settingsFile)).toString("utf-8"));
        } catch (e) {
            if (this.isDebug()) {
                helper.debug('Settings file cannot be found! No saved yet');
            }
        }

        this.reloadSettings(settings);

        this.putSettingsToView(this.settings);

        helper.live('click', '#save-settings', function (event) {
            event.preventDefault();
            let fontForgeField = document.getElementById('fontForgePath');
            let fontForgePath = fontForgeField.value.replace(/^\s+/, '').replace(/\s+/, '').replace(/\r?\n|\r/g, '');
            let canHide = true;
            if (fontForgePath !== '' && fontForgePath !== settings.fontForgePath) {
                if (scope.checkForFontForge(fontForgePath)) {
                    settings.fontForgePath = fontForgePath;
                } else {
                    canHide = false;
                    fontForgeField.classList.add("is-invalid");
                }
            } else {
                fontForgeField.classList.remove("is-invalid");
            }

            settings.debug = document.getElementById("debug").checked ? 1 : 0;
            scope.reloadSettings(settings);
            scope.putSettingsToView(settings);
            if (!scope.saveSettings(scope.settings)) {
                scope.showWarning("Could not save settings to system. Please check permissions for: <strong>" + App.dataPath + "</strong>");
            }
            if (canHide) {
                scope.settingsModal.hide();
            }
        });

        helper.live('click', '#cancel-settings', function () {
            scope.putSettingsToView(settings);
        });

        if (!this.settingsGet("fontForgePath")) {
            this.checkForFontForge();
        }
    },

    /** ----------------------- settings ----------------------- **/

    allowedFontTypes: ["ttf", "otf"],
    fontFiles: [],

    clearButton: document.getElementById('clear-list'),
    convertFontsButton: document.getElementById('convert-fonts'),
    packFontsButton: document.getElementById('pack-fonts'),
    statusBar: document.getElementById('status-bar'),
    loader: document.getElementById('loader'),
    settingsModal: (new bn.Modal(document.getElementById('settings-window'))),
    aboutModal: (new bn.Modal(document.getElementById('about'))),

    generatedFonts: [],

    weightOptions: {
        "100": "Extra light (100)",
        "200": "Thin (200)",
        "300": "Light (300)",
        "400": "Regular (400)",
        "500": "Medium (500)",
        "600": "Semi Bold (600)",
        "700": "Bold (700)",
        "800": "Black (800)",
        "900": "Extra Black (900)"
    },

    styleOptions: {
        "normal": "Normal",
        "italic": "Italic"
    },

    tempPath: path.join(App.dataPath, 'Temp'),

    isDebug: function () {
        return this.settings.debug === 1;
    },

    debugger: function () {
        if (this.isDebug()) {
            helper.debug("App Config path: " + App.dataPath);
            helper.debug("Temp path:" + this.tempPath);
        }
    },

    /**
     * Setting message in status bar
     * @param message
     */
    setStatusMessage: function (message) {
        this.statusBar.innerHTML = message;
    },

    /**
     * setting warning message
     * @param text
     */
    showWarning: function (text) {
        let warnings = document.getElementsByClassName('alert-danger');
        if (warnings.length > 0) {
            warnings[0].innerHTML = text;
        } else {
            helper.prepend(document.getElementsByClassName('container')[0], '<div class="alert alert-danger alert-dismissible fade show" role="alert">' + text + '</div>');
        }
    },

    clickEvents: function () {
        let scope = this;
        helper.live('click', '.show-settings', function (event) {
            let el = this;
            let options = {
                focus: el.dataset.focus
            };
            event.preventDefault();
            scope.settingsWindow(options);
        });
    },

    fileChooser: function () {
        let scope = this;
        document.getElementById('chose-fonts').addEventListener('click', function (event) {
            event.preventDefault();

            let chooser = document.querySelector("#fonts");
            chooser.addEventListener("change", function () {
                scope.parseFonts(this.value);
                scope.rebuildList();
                this.value = '';
            }, false);

            chooser.click();
        }, false);
    },

    /**
     *
     * @param fonts
     * @returns {*}
     */
    parseFonts: function (fonts) {
        helper.show(this.loader);
        if (fonts) {
            fonts = fonts.split(';');
            for (let i = 0; i < fonts.length; i++) {
                let ext = this.getExtension(fonts[i]);
                if (this.allowedFontTypes.indexOf(ext) !== -1) {
                    if (!this.isDuplicate(fonts[i])) this.fontFiles.push(fonts[i]);
                }
            }
        }

        if (this.fontFiles.length > 0) {
            helper.show(this.clearButton);
            helper.show(this.convertFontsButton);
            this.setStatusMessage("Fonts loaded");
        } else {
            helper.hide(this.clearButton);
            helper.hide(this.convertFontsButton);
            this.setStatusMessage("No fonts found. Please chose ttf or otf font file/s");
        }
        helper.hide(this.loader);
    },

    getExtension: function (fontName) {
        return fontName.split('.').pop().toLowerCase();
    },

    isDuplicate: function (font) {
        font = font.replace(/\.(otf|ttf)$/, '');
        for (let i in this.fontFiles) {
            if (this.fontFiles.hasOwnProperty(i)) {
                if (this.fontFiles[i].replace(/\.(otf|ttf)$/, '') === font) {
                    return true;
                }
            }
        }
        return false;
    },

    rebuildList: function () {
        helper.show(this.loader);
        let tBody = document.querySelector("#font-table tbody");

        let currentList = this.currentList();

        tBody.innerHTML = '';

        for (let i = 0; i < this.fontFiles['length']; i++) {
            let font = path.normalize(this.fontFiles[i]);
            let fontName = font.split('/').pop();
            let curWeight = null, curStyle = null, curName = '';

            if (typeof currentList[fontName] !== 'undefined') {
                curWeight = currentList[fontName].weight;
                curStyle = currentList[fontName].style;
                curName = currentList[fontName].name;
            } else {
                curWeight = this.getWeight(fontName);
                curStyle = this.getStyle(fontName);
                curName = fontName.replace(/\.[a-z]+$/i, '');
                curName = curName.replace(/-[a-z0-9]+$/i, '');
            }

            let html = '<tr data-file="' + font + '" data-name="' + fontName + '">'
                + '<td class="strong">' + fontName + '</td>'
                + '<td><input class="form-control" name="name[\'' + fontName + '\']" value="' + curName + '"></td>'
                + '<td>' + this.makeSelect("weight['" + fontName + "']", this.weightOptions, curWeight) + '</td>'
                + '<td>' + this.makeSelect("style['" + fontName + "']", this.styleOptions, curStyle) + '</td>'
                + '<td><a href="%23" class="btn btn-sm btn-danger remove-font"><i class="delete"></i></a></td>'
                + '</tr>';
            helper.append(tBody, html);
        }
        helper.hide(this.loader);
    },

    removeItem: function () {
        let scope = this;
        helper.live('click', '.remove-font', function (event) {
            event.preventDefault();

            let row = this.parentNode.parentNode;
            for (let i = 0; i < scope.fontFiles.length; i++) {
                if (scope.fontFiles.hasOwnProperty(i)) {
                    if (scope.fontFiles[i] === row.dataset.file) {
                        scope.fontFiles.splice(i, 1);
                        break;
                    }
                }
            }

            scope.setStatusMessage("Font <strong>" + row.dataset.name + "</strong> removed");

            row.parentNode.removeChild(row);

            if (scope.fontFiles.length === 0) {
                helper.hide(scope.clearButton);
                helper.hide(scope.convertFontsButton);
            }

        });
    },

    clearList: function () {
        let scope = this;
        this.clearButton.addEventListener('click', function (event) {
            event.preventDefault();
            let rows = document.querySelector("#font-table tbody");
            rows.innerHTML = '';
            this.fontFiles = [];
            helper.hide(this);
            scope.setStatusMessage("Font list cleared");
        }, false);
    },

    getWeight: function (font) {
        let regexp;
        //thin
        regexp = /(extralightthin|extralightitalic)\.(ttf|otf)$/i;
        if (font.match(regexp)) return "100";

        //thin
        regexp = /(thin|thinitalic)\.(ttf|otf)$/i;
        if (font.match(regexp)) return "200";

        //light
        regexp = /(book|demi|light|bookitalic|demiitalic|lightitalic)\.(ttf|otf)$/i;
        if (font.match(regexp)) return "300";

        //medium
        regexp = /(medium|mediumitalic)\.(ttf|otf)$/i;
        if (font.match(regexp)) return "500";

        //semi-bold
        regexp = /(semibold|demibold|demibolditalic|semibolditalic)\.(ttf|otf)$/i;
        if (font.match(regexp)) return "600";

        //black
        regexp = /(flat|extrablack|extrablackitalic|flatitalic|poster|posteritalic|utlrablack|ultrablackitalic)\.(ttf|otf)$/i;
        if (font.match(regexp)) return "900";

        //bold
        regexp = /(black|heavy|extrabold|blackitalic|heavyitalic|extrabolditalic)\.(ttf|otf)$/i;
        if (font.match(regexp)) return "800";

        //bold
        regexp = /(bold|bolditalic)\.(ttf|otf)$/i;
        if (font.match(regexp)) return "700";

        //default regular
        return "400";
    },

    getStyle: function (font) {
        if (font.match(/(italic|it)\.(ttf|otf)$/i)) return "italic";
        return "normal";
    },

    makeSelect: function (name, options, current) {
        let selectGroup = '<select class="form-control" name="' + name + '">';
        for (let val in options) {
            if (options.hasOwnProperty(val)) {
                selectGroup += '<option value="' + val + '" ' + (current === val ? 'selected="selected"' : '') + '>' + options[val] + '</option>';
            }
        }
        selectGroup += '</select>';
        return selectGroup;
    },

    currentList: function () {
        let tBody = document.querySelector("#font-table tbody");
        let currentList = [];

        for (let i = 0, row; row = tBody.rows[i]; i++) {
            let selects = row.getElementsByTagName('select');
            let fontName = row.dataset.name;
            let name = row.getElementsByTagName('input')[0].value;
            let path = row.dataset.file;
            currentList[fontName] = {
                weight: selects[0].options[selects[0].selectedIndex].value,
                style: selects[1].options[selects[1].selectedIndex].value,
                path: path,
                name: name
            }
        }

        return currentList;
    },

    generateFonts: function () {
        let scope = this;
        this.convertFontsButton.addEventListener('click', function (event) {
            event.preventDefault();
            helper.show(scope.loader);
            new Promise((resolve, reject) => {
                let currentList = scope.currentList();
                let listLength = Object.keys(currentList).length;
                if (listLength > 0) {
                    let iteration = 0;
                    for (let fontName in currentList) {
                        if (currentList.hasOwnProperty(fontName)) {
                            let ext = scope.getExtension(fontName);
                            scope.setStatusMessage(fontName);
                            scope.copy(currentList[fontName].path, scope.tempPath);
                            scope.generatedFonts[fontName] = {
                                name: currentList[fontName].name,
                                style: currentList[fontName].style,
                                weight: currentList[fontName].weight
                            };

                            if (ext === 'otf') {
                                scope.makeTTF(currentList[fontName].path, fontName).then((ttfFont) => {
                                    scope.makeFonts(ttfFont, fontName).then(() => {
                                        iteration++;
                                        if (iteration === listLength) {
                                            resolve();
                                        }
                                    });
                                }, (err) => {
                                    new Error("OTF to TTF error: " + err);
                                });
                            } else {
                                scope.ttfInfo(currentList[fontName].path, fontName).then((ttfFont) => {
                                    scope.copy(currentList[fontName].path, scope.tempPath, ttfFont.fontFile);
                                    scope.makeFonts(ttfFont, fontName).then(() => {
                                        iteration++;
                                        if (iteration === listLength) {
                                            resolve();
                                        }
                                    });
                                }, (err) => {
                                    new Error("OTF to TTF error: " + err);
                                });
                            }

                        }
                    }
                } else {
                    reject();
                }
            }).then(() => {
                scope.generateCss().then(() => {
                    scope.setStatusMessage("Font converting done. Proceed to save!");
                    helper.hide(scope.convertFontsButton);
                    helper.show(scope.packFontsButton);
                    helper.hide(scope.loader);
                }, (error) => {
                    new Error("CSS Write error: " + error);
                });
            }, () => {
                scope.setStatusMessage("Font list is empty. Nothing to do");
                helper.hide(scope.convertFontsButton);
                new Error("Error converting fonts");
            });
        }, false);
    },

    /**
     *
     * @param script string
     * @param font string
     * @param convertTo string
     * @return {Promise}
     */
    fontForge: function (script, font, convertTo) {
        convertTo = convertTo || '';
        let cmd = this.settingsGet('fontForgePath') + ' -script "' + script + '" "' + font + '" "' + this.tempPath + '" "' + convertTo + '"';

        return new Promise((resolve, reject) => {
            exec(cmd, (error, stdout) => error ? reject(error) : resolve(JSON.parse(stdout)));
        });
    },

    makeFonts: function (ttfFont, fontName) {
        this.generatedFonts[fontName].ttf = path.join(ttfFont.fontPath, ttfFont.fontFile);
        this.generatedFonts[fontName].ttfName = ttfFont.fontFile;
        return this.makeEOT(ttfFont, fontName)
            .then(() => {
                this.makeSVG(ttfFont).then((svgFont) => {
                    this.generatedFonts[fontName].svg = path.join(svgFont.fontPath, svgFont.fontFile);
                    this.generatedFonts[fontName].svgName = svgFont.fontFile;

                }, (error) => {
                    helper.debug("SVG error: " + error);
                });
            }, (error) => {
                helper.debug("EOT error: " + error);
            }).then(() => {
                this.makeWOFF(ttfFont).then((woffFont) => {
                    this.generatedFonts[fontName].woff = path.join(woffFont.fontPath, woffFont.fontFile);
                    this.generatedFonts[fontName].woffName = woffFont.fontFile;
                }, (error) => {
                    helper.debug("WOFF error: " + error);
                });
            }, (error) => {
                helper.debug("WOFF error: " + error);
            }).then(() => {
                this.makeWOFF2(ttfFont).then((woff2Font) => {
                    this.generatedFonts[fontName].woff2 = path.join(woff2Font.fontPath, woff2Font.fontFile);
                    this.generatedFonts[fontName].woff2Name = woff2Font.fontFile;
                }, (error) => {
                    helper.debug("WOFF2 error: " + error);
                });
            }, (error) => {
                helper.debug("WOFF2 error: " + error);
            });
    },

    /**
     *
     * @param fontPath string
     * @param ttfFont string
     * @returns {*|Buffer|string}
     */
    ttfInfo: function (fontPath, ttfFont) {
        this.setStatusMessage(ttfFont + ": TTF info...");
        let script = path.join(process.cwd(), 'shell-scripts', 'ttfInfo.pe');
        helper.debug("Getting ttf info: " + ttfFont);
        return this.fontForge(script, fontPath);
    },

    /**
     *
     * @param otfFont string
     * @param fontName string
     * @returns {promise}
     */
    makeTTF: function (otfFont, fontName) {
        this.setStatusMessage(fontName + ": OTF to TTF");
        let script = path.join(process.cwd(), 'shell-scripts', 'convert.pe');
        helper.debug("OTF to TTF: " + fontName);
        return this.fontForge(script, otfFont, 'ttf');
    },

    /**
     *
     * @param ttfFont object
     * @param fontName string
     * @returns {Promise}
     */
    makeEOT: function (ttfFont, fontName) {
        /**
         * @typedef string ttfFont.fontPath
         * @typedef string ttfFont.fontFile
         * @typedef string ttfFont.fontName
         * @type {Buffer | string}
         */
        this.setStatusMessage(ttfFont.fontFile + ": TTF to EOT");

        return new Promise((resolve, reject) => {
            try {
                let input = fs.readFileSync(path.join(ttfFont.fontPath, ttfFont.fontFile));
                let ttf = new Uint8Array(input);
                let eot = new Buffer(ttf2eot(ttf).buffer);
                let fontFile = ttfFont.fontFile.replace(/\.ttf$/, '') + '.eot';
                fs.writeFileSync(path.join(this.tempPath, fontFile), eot);
                helper.debug("TTF to EOT: " + fontFile);
                this.generatedFonts[fontName].eot = path.join(ttfFont.fontPath, fontFile);
                this.generatedFonts[fontName].eotName = fontFile;
                resolve(helper.extend({}, ttfFont, {fontFile: fontFile}));
            } catch (e) {
                reject(e);
            }
        });
    },

    makeSVG: function (ttfFont) {
        this.setStatusMessage(ttfFont.fontFile + ": TTF to SVG");
        let fontFile = path.join(ttfFont.fontPath, ttfFont.fontFile);
        let script = path.join(process.cwd(), 'shell-scripts', 'convert.pe');
        helper.debug("TTF to SVG: " + ttfFont.fontFile);
        return this.fontForge(script, fontFile, 'svg');
    },

    makeWOFF: function (ttfFont) {
        this.setStatusMessage(ttfFont.fontFile + ": TTF to WOFF");
        let fontFile = path.join(ttfFont.fontPath, ttfFont.fontFile);
        let script = path.join(process.cwd(), 'shell-scripts', 'convert.pe');
        helper.debug("TTF to WOFF: " + ttfFont.fontFile);
        return this.fontForge(script, fontFile, 'woff');
    },

    makeWOFF2: function (ttfFont) {
        this.setStatusMessage(ttfFont.fontFile + ": TTF to WOFF2");
        let fontFile = path.join(ttfFont.fontPath, ttfFont.fontFile);
        let script = path.join(process.cwd(), 'shell-scripts', 'convert.pe');
        helper.debug("TTF to WOFF2: " + ttfFont.fontFile);
        return this.fontForge(script, fontFile, 'woff2');
    },

    /**
     * @return {Promise}
     */
    generateCss: function () {
        this.setStatusMessage("Generating CSS");
        helper.debug(this.generatedFonts);
        return new Promise((resolve, reject) => {
            let css = "";
            if (Object.keys(this.generatedFonts).length > 0) {
                for (let fontName in this.generatedFonts) {
                    if (this.generatedFonts.hasOwnProperty(fontName)) {
                        css += "@font-face {\n";
                        css += "\tfont-family: '" + this.generatedFonts[fontName].name + "';\n";
                        css += "\tfont-weight: '" + this.generatedFonts[fontName].weight + "';\n";
                        css += "\tfont-style: '" + this.generatedFonts[fontName].style + "';\n";
                        css += "\tsrc: url('../fonts/" + this.generatedFonts[fontName].eotName + "#iefix') format('embedded-opentype'),\n";
                        css += "\t\turl('../fonts/" + this.generatedFonts[fontName].woff2Name + "') format('woff2'),\n";
                        css += "\t\turl('../fonts/" + this.generatedFonts[fontName].woffName + "') format('woff'),\n";
                        css += "\t\turl('../fonts/" + this.generatedFonts[fontName].ttfName + "') format('truetype'),\n";
                        css += "\t\turl('../fonts/" + this.generatedFonts[fontName].svgName + "') format('svg');\n";
                        css += "};\n\n";
                    }
                }
            }

            helper.debug(css);

            fs.writeFile(path.join(this.tempPath, 'fonts-style.css'), css, "utf8", (err) => {
                if (err) reject(err);
                else resolve();
            });
        });
    },

    pack: function () {
        let scope = this;
        this.packFontsButton.addEventListener('click', function (event) {
            event.preventDefault();
            document.getElementById("save-to").click();
        });
        document.getElementById('save-to').addEventListener('change', function (event) {
            scope.setStatusMessage("Packing fonts");
            helper.show(scope.loader);
            event.preventDefault();
            if (this.value === '') return false;
            helper.debug("fired save to " + this.value);
            scope.setStatusMessage("Creating directories");
            let savePath = this.value;
            if (!fs.existsSync(savePath)) {
                fs.mkdirSync(savePath);
            }


            let fontsDir = path.join(savePath, 'fonts');
            if (!fs.existsSync(fontsDir)) {
                fs.mkdirSync(fontsDir);
            }
            // this.emptyDirectory(fontsDir);

            let cssDir = path.join(savePath, 'css');
            if (!fs.existsSync(cssDir)) {
                fs.mkdirSync(cssDir);
            }
            // this.emptyDirectory(cssDir);

            scope.setStatusMessage("Copying fonts");
            if (Object.keys(scope.generatedFonts).length > 0) {
                for (let fontName in scope.generatedFonts) {
                    if (scope.generatedFonts.hasOwnProperty(fontName)) {
                        scope.setStatusMessage("Copying: " + fontName);
                        scope.copy(scope.generatedFonts[fontName].ttf, fontsDir);
                        scope.copy(scope.generatedFonts[fontName].eot, fontsDir);
                        scope.copy(scope.generatedFonts[fontName].svg, fontsDir);
                        scope.copy(scope.generatedFonts[fontName].woff, fontsDir);
                        scope.copy(scope.generatedFonts[fontName].woff2, fontsDir);
                    }
                }
            }
            scope.setStatusMessage("Copying css");
            scope.copy(path.join(scope.tempPath, 'fonts-style.css'), cssDir, 'fonts.css');
            scope.copy(path.resolve('./', 'fonts-done-tpl.html'), savePath, 'readme.html');
            scope.setStatusMessage("Collecting garbage...");
            scope.emptyTemp();
            let rows = document.querySelector("#font-table tbody");
            rows.innerHTML = '';
            this.fontFiles = [];
            scope.generatedFonts = [];
            helper.hide(scope.packFontsButton);
            scope.setStatusMessage("All done!");
            nw.Shell.showItemInFolder(path.join(savePath, 'readme.html'));
            this.value = '';
            helper.hide(scope.loader);
        }, false);
    },

    copy: function (sourceFile, targetDir, newName) {
        newName = newName || sourceFile.split('/').pop();
        if (!fs.existsSync(targetDir)) {
            fs.mkdirSync(targetDir);
        }
        let targetFile = path.join(targetDir, newName);
        fs.copyFileSync(sourceFile, targetFile);
    },

    emptyDirectory: function (dir, firstDir) {
        firstDir = firstDir || true;
        let scope = this;
        if (fs.existsSync(dir)) {
            fs.readdirSync(dir).forEach(function (file) {
                let curPath = path.join(dir, file);
                if (fs.lstatSync(curPath).isDirectory()) { // recurse
                    scope.emptyDirectory(curPath, false);
                } else { // delete file
                    fs.unlinkSync(curPath);
                }
            });
            if (!firstDir) {
                fs.rmdirSync(dir);
            }
        }
    },

    emptyTemp: function () {
        this.emptyDirectory(this.tempPath);
    },

    /**
     * get fontforge Path
     */
    checkForFontForge: function (rewritePath) {
        rewritePath = rewritePath || false;
        helper.show(this.loader);
        let fontForgePath = false;
        let stdout = null;
        if (rewritePath) {
            try {
                rewritePath = rewritePath.replace(/\r?\n|\r/g, '');
                stdout = execSync(rewritePath + ' -version');
                this.settingsSet("fontForgePath", rewritePath);
                if (this.isDebug()) {
                    helper.debug("Custom ff path: " + stdout.toString());
                }
                return true;
            } catch (e) {
                if (this.isDebug()) {
                    helper.debug(e);
                }
                return false;
            }
        }
        switch (os.platform()) {
            case 'darvin' : // macOs
                // get command
                break;
            case 'linux':
                try {
                    stdout = execSync('command -v fontforge');
                    fontForgePath = stdout.toString();
                    if (this.isDebug()) {
                        helper.debug("command: " + fontForgePath);
                    }
                    this.settingsSet("fontForgePath", fontForgePath.replace(/\r?\n|\r/g, ''));
                } catch (e) {
                    if (this.isDebug()) {
                        helper.debug(e);
                    }
                }
                break;
            case "win32":
            case "win64":
                //windows
                break;
            default:
                return false;
        }

        if (!this.settingsGet("fontForgePath")) {
            this.showWarning("Cannot Find dependency: <strong>fontforge</strong>. Please install it from <a target='_blank' href='https://fontforge.github.io'>FontForge official page</a> or provide path to executable in <a href='%23' data-focus='fontForgePath' class='show-settings'>Settings</a>!");
        }

        helper.hide(this.loader);
    },

    buildMenu: function () {

        let scope = this;

        let fileMenu = new nw.MenuItem({
            label: "File",
            key: "f",
            modifiers: "alt"
        });

        let menu = new nw.Menu({type: "menubar"});

        let fileSubMenu = new nw.Menu();
        fileSubMenu.append(new nw.MenuItem({
            label: "Settings",
            click: function () {
                scope.settingsWindow();
            },
            key: "s",
            modifiers: "alt"
        }));
        fileSubMenu.append(new nw.MenuItem({type: "separator"}));
        fileSubMenu.append(new nw.MenuItem({
            label: "About",
            click: function () {
                document.getElementById('version-tag').innerHTML = process.env.npm_package_version;
                scope.aboutModal.show();
            },
            key: "a",
            modifiers: "alt"
        }));

        fileMenu.submenu = fileSubMenu;

        menu.append(fileMenu);

        win.menu = menu;
    }
};

app.init();